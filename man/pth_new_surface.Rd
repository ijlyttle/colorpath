% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/surface.R, R/trajectory.R
\name{pth_new_surface}
\alias{pth_new_surface}
\alias{pth_new_surface.default}
\alias{pth_new_surface.character}
\alias{pth_new_surface.pth_mat}
\alias{pth_new_trajectory}
\title{Create surfaces and trajectories}
\usage{
pth_new_surface(colors, route = c("short", "long"), n_step = 30, ...)

\method{pth_new_surface}{default}(colors, route = c("short", "long"), n_step = 30, ...)

\method{pth_new_surface}{character}(
  colors,
  route = c("short", "long"),
  n_step = 30,
  transformer = pth_to_cieluv,
  ...
)

\method{pth_new_surface}{pth_mat}(colors, route = c("short", "long"), n_step = 30, ...)

pth_new_trajectory(lum, chroma)
}
\arguments{
\item{colors}{\code{character} hex-codes, or matrix with object with
S3 class \code{pth_mat}. Must have one or two elements.}

\item{route}{\code{character}, indicates which direction to take around the
circle; must be either \code{"short"} (default), or \code{"long"}.}

\item{n_step}{(\code{double} coerced to) \code{integer} number of steps to take along
luminance domain to calculate maximum chroma.}

\item{...}{other args, not used}

\item{transformer}{\code{function} used to transform to a color space.
Used if \code{colors} are hex-codes.}

\item{lum}{\code{numeric} values for luminance, \verb{0 <= lum <= 100}.}

\item{chroma}{\code{numeric} values for chroma, \code{0 <= chroma}.}
}
\value{
\describe{
\item{\code{pth_new_surface()}}{\code{list} with S3 class \code{pth_surface}, elements:
\code{fn_hue()}: for each given value of luminance \verb{0 <= lum <= 100},
returns a value for hue (degrees),
\code{fn_max_chroma()}: for each given value of luminance \verb{0 <= lum <= 100},
returns a value for maximum chroma.}
\item{\code{pth_new_trajectory()}}{\code{function} with S3 class
\code{pth_trajectory}: for each given value \verb{0 <= x <= 1}, returns a
set of luminance and chroma values as a matrix.}
}
}
\description{
The central idea of this package is to create sequential palettes by
projecting a chroma trajectory onto a hue surface. Use these functions to
build the surfaces and trajectories.

These functions themselves return functions.

The function \code{pth_new_surface()} takes one or two values of \code{hue} and two
values of \code{lum}. It returns a function that returns \code{hue} as a linear function
of \code{lum}.

The function \code{pth_new_trajectory()} takes an equal number of \code{lum}
and \code{chroma} values. These serve as control points for a BÃ©zier curve.
It returns a function that given input values \verb{0 <= x <= 1}, returns
a matrix with as many rows as input values; \code{lum} and \code{chroma} are the
columns.

One thing to keep in mind when designing a trajectory: although it is a good
thing to keep the trajectory within the gamut, it is not necessary
(or perhaps not even desirable) to keep the control points within the gamut.
}
\examples{
 # create surfaces using hex-codes
 sfc <- pth_new_surface(c("#0000FF", "#00FFFF"))

 # get hue using luminance
 sfc$fn_hue(c(0, 50, 100))

 # get maximum-chroma using luminance
 sfc$fn_max_chroma(c(0, 50, 100))

 # create a trajectory
 traj <-
   pth_new_trajectory(chroma = c(0, 100, 0), lum = c(20, 50, 80))
 traj(seq(0, 1, by = 0.1))

}
